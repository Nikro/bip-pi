"""
State management for the UI node.

This module maintains and updates the system state for the UI display.
It keeps track of the current state of the system and provides
methods for updating and querying the state.
"""

import time
from enum import Enum, auto
from typing import Dict, Any, List, Optional, Callable, Deque
from collections import deque


class SystemMode(Enum):
    """Enum representing the system's current operational mode."""
    IDLE = auto()
    LISTENING = auto()
    PROCESSING = auto()
    RESPONDING = auto()
    ERROR = auto()


class UIState:
    """
    Maintains and updates the system state for the UI.
    
    This class manages the current state of the system and notifies
    registered listeners when state changes occur.
    """
    
    def __init__(self):
        """Initialize the UI state with default values."""
        # Current system state
        self._mode = SystemMode.IDLE
        self._last_message = ""
        self._last_response = ""
        self._error_message = ""
        self._last_update_time = time.time()
        
        # Animation and display state
        self._animation_frame = 0
        self._brightness = 1.0
        self._show_debug = False
        
        # Performance metrics
        self._fps = 0
        self._cpu_usage = 0.0
        self._memory_usage = 0.0
        
        # Awareness data tracking
        self._awareness_data = {
            "last_transcript": "",
            "last_recording_path": "",
            "last_recording_duration": 0.0,
            "detected_language": "",
            "last_trigger_time": 0
        }
        
        # History of transcripts (most recent first)
        self._transcript_history: Deque[Dict[str, Any]] = deque(maxlen=5)
        
        # Registered listeners for state changes
        self._listeners: List[Callable[[str, Any], None]] = []
    
    @property
    def mode(self) -> SystemMode:
        """Get the current system mode."""
        return self._mode
    
    @mode.setter
    def mode(self, value: SystemMode) -> None:
        """
        Set the current system mode.
        
        Args:
            value: The new system mode
        """
        if self._mode != value:
            old_value = self._mode
            self._mode = value
            self._last_update_time = time.time()
            self._notify_listeners("mode", (old_value, value))
    
    @property
    def last_message(self) -> str:
        """Get the last message received from the user."""
        return self._last_message
    
    @last_message.setter
    def last_message(self, value: str) -> None:
        """
        Set the last message received from the user.
        
        Args:
            value: The new message
        """
        if self._last_message != value:
            self._last_message = value
            self._last_update_time = time.time()
            self._notify_listeners("last_message", value)
    
    @property
    def last_response(self) -> str:
        """Get the last response generated by the system."""
        return self._last_response
    
    @last_response.setter
    def last_response(self, value: str) -> None:
        """
        Set the last response generated by the system.
        
        Args:
            value: The new response
        """
        if self._last_response != value:
            self._last_response = value
            self._last_update_time = time.time()
            self._notify_listeners("last_response", value)
    
    @property
    def last_transcript(self) -> str:
        """Get the last transcript from audio monitoring."""
        return self._awareness_data["last_transcript"]
    
    @last_transcript.setter
    def last_transcript(self, value: str) -> None:
        """
        Set the last transcript from audio monitoring.
        
        Args:
            value: The new transcript text
        """
        if self._awareness_data["last_transcript"] != value:
            self._awareness_data["last_transcript"] = value
            self._last_update_time = time.time()
            self._notify_listeners("last_transcript", value)
    
    @property
    def transcript_history(self) -> List[Dict[str, Any]]:
        """Get the history of transcripts (most recent first)."""
        return list(self._transcript_history)
    
    def add_transcript(self, transcript: str, recording_path: str, duration: float) -> None:
        """
        Add a new transcript to the history.
        
        Args:
            transcript: The transcribed text
            recording_path: Path to the recording file
            duration: Duration of the recording in seconds
        """
        if not transcript:
            return
            
        entry = {
            "text": transcript,
            "path": recording_path,
            "duration": duration,
            "timestamp": time.time()
        }
        
        self._transcript_history.appendleft(entry)
        self.last_transcript = transcript
        self._awareness_data["last_recording_path"] = recording_path
        self._awareness_data["last_recording_duration"] = duration
        
        # Notify about transcript history change
        self._notify_listeners("transcript_history", self.transcript_history)
    
    @property
    def error_message(self) -> str:
        """Get the current error message, if any."""
        return self._error_message
    
    @error_message.setter
    def error_message(self, value: str) -> None:
        """
        Set the current error message.
        
        Args:
            value: The new error message
        """
        if self._error_message != value:
            self._error_message = value
            if value:  # Only update mode if there's an error
                self.mode = SystemMode.ERROR
            self._last_update_time = time.time()
            self._notify_listeners("error_message", value)
    
    @property
    def animation_frame(self) -> int:
        """Get the current animation frame."""
        return self._animation_frame
    
    @animation_frame.setter
    def animation_frame(self, value: int) -> None:
        """
        Set the current animation frame.
        
        Args:
            value: The new animation frame
        """
        self._animation_frame = value
        # No notification for animation frames to avoid spam
    
    @property
    def brightness(self) -> float:
        """Get the current brightness level (0.0 to 1.0)."""
        return self._brightness
    
    @brightness.setter
    def brightness(self, value: float) -> None:
        """
        Set the current brightness level.
        
        Args:
            value: The new brightness level (0.0 to 1.0)
        """
        self._brightness = max(0.0, min(1.0, value))
        self._notify_listeners("brightness", self._brightness)
    
    @property
    def show_debug(self) -> bool:
        """Check if debug information should be displayed."""
        return self._show_debug
    
    @show_debug.setter
    def show_debug(self, value: bool) -> None:
        """
        Set whether debug information should be displayed.
        
        Args:
            value: True to show debug info, False to hide
        """
        if self._show_debug != value:
            self._show_debug = value
            self._notify_listeners("show_debug", value)
    
    @property
    def fps(self) -> int:
        """Get the current frames per second count."""
        return self._fps
    
    @fps.setter
    def fps(self, value: int) -> None:
        """
        Set the current frames per second count.
        
        Args:
            value: The new FPS count
        """
        self._fps = value
        # No notification for FPS to avoid spam
    
    @property
    def cpu_usage(self) -> float:
        """Get the current CPU usage percentage."""
        return self._cpu_usage
    
    @cpu_usage.setter
    def cpu_usage(self, value: float) -> None:
        """
        Set the current CPU usage percentage.
        
        Args:
            value: The new CPU usage percentage
        """
        self._cpu_usage = value
        # No notification for CPU usage to avoid spam
    
    @property
    def memory_usage(self) -> float:
        """Get the current memory usage in MB."""
        return self._memory_usage
    
    @memory_usage.setter
    def memory_usage(self, value: float) -> None:
        """
        Set the current memory usage.
        
        Args:
            value: The new memory usage in MB
        """
        self._memory_usage = value
        # No notification for memory usage to avoid spam
    
    @property
    def last_update_time(self) -> float:
        """Get the timestamp of the last state update."""
        return self._last_update_time
    
    def register_listener(self, listener: Callable[[str, Any], None]) -> None:
        """
        Register a listener for state changes.
        
        Args:
            listener: Callback function that takes (property_name, new_value)
        """
        if listener not in self._listeners:
            self._listeners.append(listener)
    
    def unregister_listener(self, listener: Callable[[str, Any], None]) -> None:
        """
        Unregister a listener.
        
        Args:
            listener: The listener to remove
        """
        if listener in self._listeners:
            self._listeners.remove(listener)
    
    def _notify_listeners(self, property_name: str, value: Any) -> None:
        """
        Notify all registered listeners of a state change.
        
        Args:
            property_name: Name of the property that changed
            value: New value of the property
        """
        for listener in self._listeners:
            try:
                listener(property_name, value)
            except Exception as e:
                print(f"Error notifying listener about {property_name}: {e}")
    
    def update_from_message(self, message: Dict[str, Any]) -> None:
        """
        Update state based on a received message.
        
        Args:
            message: Message dictionary containing state updates
        """
        msg_type = message.get("type")
        payload = message.get("payload", {})
        
        if msg_type == "trigger_event":
            # Handle trigger events
            trigger_type = payload.get("trigger_type")
            data = payload.get("data", {})
            
            if trigger_type == "audio":
                # Handle audio trigger
                self.mode = SystemMode.LISTENING
                
                # Process audio transcript
                transcript = data.get("transcript", "")
                recording_path = data.get("recording_path", "")
                duration = data.get("duration", 0.0)
                
                if transcript:
                    self.add_transcript(transcript, recording_path, duration)
                    self.last_message = transcript
        
        elif msg_type == "response":
            # Handle responses
            self.mode = SystemMode.RESPONDING
            self.last_response = payload.get("response", "")
        
        elif msg_type == "error":
            # Handle errors
            self.error_message = payload.get("message", "Unknown error")
        
        # Update the timestamp
        self._last_update_time = time.time()
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert current state to a dictionary.
        
        Returns:
            Dictionary representation of the current state
        """
        return {
            "mode": self._mode.name,
            "last_message": self._last_message,
            "last_response": self._last_response,
            "error_message": self._error_message,
            "last_update_time": self._last_update_time,
            "show_debug": self._show_debug,
            "fps": self._fps,
            "cpu_usage": self._cpu_usage,
            "memory_usage": self._memory_usage,
            "awareness": self._awareness_data,
            "transcript_history": list(self._transcript_history)
        }


# Create a singleton instance for global state
global_state = UIState()
